# Kubernetes and Docker


## Kubernetes

#### 1 Kubernetes 诞生的因素

今天，大型单体应用正被逐渐分解为小的、可独立运行的组件，我们称之为**微服务**。微服务彼此之间解耦，所以它们可以被独立开发、部署、升级、伸缩。这使得我们可以对每一个微服务实现快速迭代，并且迭代的速度可以和市场需求的变化的速度保持一致。

随着部署组件的增多和数据中心的增长，配置、管理并保持系统的正常运行变得越来越困难。如今我们需要一些自动化的措施，包括自动调度、配置、监管和故障处理。这正是 Kubernetes 的用武之地。

系统管理员的运维工作重心，从监管应用转移到了监管 Kubernetes，以及剩余的系统资源，因为 Kubernetes 会帮助监管所有的应用。

#### 2 Kubernetes 的抽象层

Kubernetes 抽象了数据中心的硬件基础设施，使得对外暴露的只是一个巨大的资源池。使用 Kubernetes 部署多组件应用时，它能够保证每个组件可以轻易地发现其他组件，并彼此之间实现通信。

微服务以团队形式完成工作，所以需要找到彼此进行交流。同时，部署微服务时，部署者需要正确地配置所有服务来使其作为一个单一系统能正确工作。

不管你同时开发和部署多少个独立组件，开发和运维团队总是需要解决的一个最大的问题是程序运行环境的差异性，这种巨大差异不仅存在于开发环境与生产环境之间，甚至存在于各个生产机器之间。

一个生产系统必须给所有它需要承载的应用提供合适的环境，尽管这些应用可能需要不同的，甚至带有冲突的版本库。

#### 3 迈向持续交付：DevOps 和无运维

在过去，开发团队的任务是创建应用并交付给运维团队，然后运维团队部署应用并使它运行。现在，公司都意识到，让同一个团队参与应用的开发、部署、运维的整个生命周期更好。

这意味着开发者、 QA 和运维团队彼此之间的合作需要贯穿整个流程。这种实践被称为 DevOps。

- 应用程序开发者现在更趋向于将应用尽快地发布上线，通过收集用户的反馈对应用做进一步开发。（理想的状态是开发人员能够自己部署应用上线，而不需要交付给运维人员操作。）
- 理想情况是，开发者是部署程序本身，不需要知道硬件基础设施的任何情况，也不需要和运维团队交涉，这被叫作 NoOps。

Kubernetes 能让我们实现所有这些想法。通过对实际硬件做抽象，然后将自身暴露成一个平台，用于部署和运行应用程序。它允许开发者自己配置和部署应用程序，而不需要系统管理员的任何帮助。

#### 4 容器技术

Kubernetes 使用 Linux 容器技术来提供应用的隔离，所以在钻研 Kubernetes 之前，需要通过熟悉容器的基本知识来更加深入地理解 Kubernetes，包括认识存在的容器技术分支，诸如 docker 或者 rkt。

当一个应用程序的组件开始变小且数量开始增长时，如果你不想浪费硬件资源，又想持续压低硬件成本，那就不能给每个组件配置一个**虚拟机**了。这不仅仅浪费硬件资源，每个虚拟机都需要被单独配置和管理，这增加了系统管理员的工作负担。

一个**容器**里运行的进程实际上运行在宿主机的操作系统上，就像所有其他进程一样。（不像虚拟机，进程是运行在不同的操作系统上的） 但在容器里的进程仍然 是和其他进程隔离的。容器类似虚拟机，但开销小很多。

和虚拟机比较，容器更加轻量级，主要是因为每个虚拟机需要运行自己的一组系统进程。

```
- 虚拟机的主要好处是它们提供完全隔离的环境，因为每个虚拟机运行在它自己的Linux内核上，而容器都是调用同一个内核，这自然会有安全隐患。
- 记住，每个虚拟机运行它自己的一组系统服务，而容器则不会，因为它们都运行在同一个操作系统上。那也就意味着运行一个容器不用像虚拟机那样要开机，
  容器的进程可以很快被启动。
```

##### 容器隔离机制

如果多个进程运行在同一个操作系统上，那容器到底是怎样隔离它们的。有两个机制可用：

- **Linux 命名空间**，它使每个进程只看到它自己的系统视图（文件、进程、网络接口、主机名等）。
- **Linux 控制组（cgroups）**，它限制了进程能使用的资源量（CPU、内存、 网络带宽等）。

```
存在以下类型的命名空间：
• Mount (mnt)
• Process ID (pid)
• Network (net)
• Inter-process communicaion (ipd)
• UTS
• User ID (user)
每种命名空间被用来隔离一组特定的资源。例如，UTS 命名空间决定了运行在命名空间里的进程能看见哪些主机名和域名。
通过分派两个不同的 UTS 命名空间给一对进程，能使它们看见不同的本地主机名。换句话说，这两个进程就好像正在两个
不同的机器上运行一样（至少就主机名而言是这样的）。
```

```
cgroups 是一个 Linux 内核功能，它被用来限制一个进程或者一组进程的资源使用。
一个进程的资源（CPU、 内存、 网络带宽等）使用量不能超出被分配的量。
```

Docker 是第一个使容器能在不同机器之间移植的系统。它不仅简化了打包应用的流程，也简化了打包应用的库和依赖，甚至整个操作系统的文件系统能被打包成一个简单的可移植的包，这个包可以被用来在任何其他运行 docker 的机器上使用。

```
例如，如果你用整个红帽企业版 Linux(RHEL) 的文件打包了你的应用程序，不管在装有 Fedora 的开发机上运行它，
还是在装有 Debian 或者其他 Linux 发行版的服务器上运行它，应用程序都认为它运行在 RHEL 中。只是内核可能不同。
```

#### 5 Kubernetes 的核心功能

整个 Kubernetes 系统由一个主节点和若干个工作节点组成。开发者把一个应用列表提交到主节点，Kubernetes 会将它们部署到集群的工作节点。组件被部署在哪个节点对于开发者和系统管理员来说都不用关心。

开发者能指定一些应用必须一起运行，Kubernetes 将会在一个工作节点上部署它们。其他的则将被分散部署到集群中，但是不管部署在哪儿，它们都能以相同的方式互相通信。

**Kubernetes 可以被当作集群的一个操作系统来看待。它降低了开发者不得不在他们的应用里实现的一些和基础设施相关的服务的心智负担。**包括服务发现、扩容、负载均衡、自恢复，甚至集群领导者的选举。


<div align="center">
<img src="figs/kubernetes.png" width="55%">
</div>

#### 6 在 Kubernetes 中运行应用

为了在 Kubernetes 中运行应用，首先需要将应用打包进一个或多个容器镜像，再将那些镜像推送到镜像仓库，然后将应用的描述发布到 Kubernetes API 服务器。

一旦应用程序运行起来，Kubernetes 就会不断地确认应用程序的部署状态始终与你提供的描述相匹配。

#### 7 使用 Kubernetes 的好处

如果在所有服务器上部署了 Kubernetes，那么运维团队就不需要再部署应用程序。因为容器化的应用程序已经包含了运行所需的所有内容，系统管理员不需要安装任何东西来部署和运行应用程序。



## Docker
